#include "LLPD.hpp"

#if defined( STM32F302X8 )
#include "stm32f302x8.h"
#elif defined( STM32F302XC )
#include "stm32f302xc.h"
#endif

#include <limits>

static volatile float    tim6DelayVal = std::numeric_limits<float>::max(); // value for delay functions
static volatile uint32_t tim6InterruptRate = 0; 	// interrupt rate used for delay functions
static volatile float    tim6USecondMax = 0.0f; 	// when tim6USecondIncr reaches this value, the delay is over
static volatile float    tim6USecondIncr = 0.0f; 	// how much to increment per interrupt for microsecond delay
static volatile float    tim3DelayVal = std::numeric_limits<float>::max(); // value for delay functions
static volatile uint32_t tim3InterruptRate = 0; 	// interrupt rate used for delay functions
static volatile float    tim3USecondMax = 0.0f; 	// when tim6USecondIncr reaches this value, the delay is over
static volatile float    tim3USecondIncr = 0.0f; 	// how much to increment per interrupt for microsecond delay

static void timerSetup (uint32_t prescalerDivisor, uint32_t cyclesPerInterrupt, uint32_t interruptRate, TIM_TypeDef* tim,
			volatile uint32_t& timInterruptRate, volatile float& timUSecondIncr)
{
	// store sample rate for delay functions
	timInterruptRate = interruptRate;
	timUSecondIncr = 1000000.0f / static_cast<float>( timInterruptRate );

	// make sure timer is disabled during setup
	tim->CR1 &= ~(TIM_CR1_CEN);

	// set timer prescaler and auto-reload values
	tim->PSC = prescalerDivisor;
	tim->ARR = cyclesPerInterrupt;

	// allow for updates to be generated by several sources
	tim->CR1 &= ~(TIM_CR1_URS);

	// ensure update events are not disabled
	tim->CR1 &= ~(TIM_CR1_UDIS);

	// allow for dma update generation
	tim->DIER |= TIM_DIER_UDE;

	// set master mode selection to send update event as TRGO
	tim->CR2 &= ~(TIM_CR2_MMS);
	tim->CR2 |= TIM_CR2_MMS_1;

	// send an update event to apply the settings
	tim->EGR |= TIM_EGR_UG;
}

void LLPD::tim6_counter_setup (uint32_t prescalerDivisor, uint32_t cyclesPerInterrupt, uint32_t interruptRate)
{
	// reset registers
	RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST);
	RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST);

	// enable peripheral clock to TIM6
	RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;

	timerSetup( prescalerDivisor, cyclesPerInterrupt, interruptRate, TIM6, tim6InterruptRate, tim6USecondIncr );
}

void LLPD::tim3_counter_setup (uint32_t prescalerDivisor, uint32_t cyclesPerInterrupt, uint32_t interruptRate)
{
	// reset registers
	RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST);
	RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST);

	// enable peripheral clock to TIM6
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

	timerSetup( prescalerDivisor, cyclesPerInterrupt, interruptRate, TIM3, tim3InterruptRate, tim3USecondIncr );
}

static void timerEnableInterrupts (TIM_TypeDef* tim, IRQn_Type irqN)
{
	static unsigned int priority = 0x00;

	NVIC_SetPriority( irqN, priority );
	NVIC_EnableIRQ( irqN );

	tim->DIER |= TIM_DIER_UIE;

	priority++;
}

void LLPD::tim6_counter_enable_interrupts()
{
	timerEnableInterrupts( TIM6, TIM6_DAC_IRQn );
}

void LLPD::tim3_counter_enable_interrupts()
{
	timerEnableInterrupts( TIM3, TIM3_IRQn );
}

static void timerDisableInterrupts (TIM_TypeDef* tim, IRQn_Type irqN)
{
	NVIC_DisableIRQ( irqN );

	tim->DIER &= ~(TIM_DIER_UIE);
}

void LLPD::tim6_counter_disable_interrupts()
{
	timerDisableInterrupts( TIM6, TIM6_DAC_IRQn );
}

void LLPD::tim3_counter_disable_interrupts()
{
	timerDisableInterrupts( TIM3, TIM3_IRQn );
}

static void timerStart (TIM_TypeDef* tim)
{
	tim->CR1 |= TIM_CR1_CEN;
}

void LLPD::tim6_counter_start()
{
	timerStart( TIM6 );
}

void LLPD::tim3_counter_start()
{
	timerStart( TIM3 );
}

static void timerStop (TIM_TypeDef* tim)
{
	tim->CR1 &= ~(TIM_CR1_CEN);
	tim->SR  &= ~(TIM_SR_UIF);
}

void LLPD::tim6_counter_stop()
{
	timerStop( TIM6 );
}

void LLPD::tim3_counter_stop()
{
	timerStop( TIM3 );
}

static void timerClearInterruptFlag (TIM_TypeDef* tim)
{
	tim->SR &= ~(TIM_SR_UIF);
}

void LLPD::tim6_counter_clear_interrupt_flag()
{
	timerClearInterruptFlag( TIM6 );
}

void LLPD::tim3_counter_clear_interrupt_flag()
{
	timerClearInterruptFlag( TIM3 );
}

static void timerDelay (uint32_t microseconds, TIM_TypeDef* tim, volatile float& timDelayVal, volatile float& timUSecondMax)
{
	timDelayVal = 0;
	timUSecondMax = static_cast<float>( microseconds );

	// wait for delay to complete
	while ( timDelayVal < timUSecondMax ) {}
}

void LLPD::tim6_delay (uint32_t microseconds)
{
	timerDelay( microseconds, TIM6, tim6DelayVal, tim6USecondMax );
}

void LLPD::tim3_delay (uint32_t microseconds)
{
	timerDelay( microseconds, TIM3, tim3DelayVal, tim3USecondMax );
}

static bool timerHandleDelay (TIM_TypeDef* tim, volatile float& timDelayVal, volatile float& timUSecondMax, volatile float& timUSecondIncr)
{
	if ( timDelayVal < timUSecondMax )
	{
		timDelayVal += timUSecondIncr;

		return true;
	}

	return false;
}

bool LLPD::tim6_isr_handle_delay()
{
	return timerHandleDelay( TIM6, tim6DelayVal, tim6USecondMax, tim6USecondIncr );
}

bool LLPD::tim3_isr_handle_delay()
{
	return timerHandleDelay( TIM3, tim3DelayVal, tim3USecondMax, tim3USecondIncr );
}

void LLPD::tim3_sync_to_tim6()
{
	TIM3->CNT = TIM6->CNT;
}
